using AutoFixture;
using AutoFixture.Kernel;
using System.Reflection;
using Xunit.Sdk;

namespace Introduction.B_OrganisationEtPartage;

public class MemberAutoData
{
    // Données de test simplifiées
    public static IEnumerable<object[]> AdditionData => new List<object[]>
    {
        new object[] { 5, 5, 10 },
        new object[] { -5, 10, 5 }
    };

    [Theory]
    [MemberAutoData(nameof(AdditionData))]
    public void Add_ShouldReturnCorrectSum(int a, int b, int expectedSum, string autoGeneratedParam, int autoGeneretedParam2)
    {
        // Arrange
        var calculator = new Calculator_MAD();

        // Act
        var result = calculator.Add(a, b);

        // Assert
        Assert.Equal(expectedSum, result);
        Assert.NotNull(autoGeneratedParam);
        Assert.True(autoGeneretedParam2 != 0);
    }
}

public class Calculator_MAD
{
    public int Add(int a, int b) => a + b;
}

public class MemberAutoDataAttribute : DataAttribute
{
    private readonly string _memberName;
    private readonly Fixture _fixture;

    public MemberAutoDataAttribute(string memberName)
    {
        _memberName = memberName;
        _fixture = new Fixture();
    }

    public override IEnumerable<object[]> GetData(MethodInfo testMethod)
    {
        // Récupérer les données de MemberData
        var memberData = GetMemberData(testMethod);

        // Compléter chaque jeu de données avec des données générées automatiquement
        foreach (var data in memberData)
        {
            // Déterminer combien de paramètres sont déjà fournis
            var providedParamCount = data.Length;

            // Déterminer combien de paramètres le test attend au total
            var totalParamCount = testMethod.GetParameters().Length;

            // Générer des données supplémentaires pour les paramètres restants
            var result = new object[totalParamCount];

            // Copier les données existantes
            for (int i = 0; i < providedParamCount; i++)
            {
                result[i] = data[i];
            }

            // Générer des données pour les paramètres restants
            for (int i = providedParamCount; i < totalParamCount; i++)
            {
                var paramType = testMethod.GetParameters()[i].ParameterType;
                var context = new SpecimenContext(_fixture);
                result[i] = context.Resolve(paramType);
            }

            yield return result;
        }
    }

    private IEnumerable<object[]> GetMemberData(MethodInfo testMethod)
    {
        // Récupérer les données depuis le membre spécifié
        var type = testMethod.DeclaringType;
        var member = type.GetMember(_memberName,
            BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy)[0];

        if (member is PropertyInfo property)
        {
            return (IEnumerable<object[]>)property.GetValue(null);
        }
        else if (member is MethodInfo method)
        {
            return (IEnumerable<object[]>)method.Invoke(null, null);
        }
        else if (member is FieldInfo field)
        {
            return (IEnumerable<object[]>)field.GetValue(null);
        }

        throw new InvalidOperationException($"Le membre {_memberName} n'est pas un champ, une propriété ou une méthode.");
    }
}